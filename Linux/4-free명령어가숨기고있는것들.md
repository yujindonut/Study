#### cpu는 프로세스의 연산 과정에 필요한 리소스
메모리는 프로세스가 연산할 수 있는 공간을 제공해 주는 리소스

#### cpu가 사람의 뇌
메모리는 사람이 들어 갈 수 있는 공간

#### 프로세스?
프로세스는 메모리라는 공간에 자신이 필요한 함수를 넣어 두거나 변수에 값을 저장하거나 하는 방식으로 연산을 위한 공간을 확보하고 작업을 진행

#### 메모리 부족
연산을 위한 공간을 확보할 수 없고, 시스템 응답 불가 현상, 큰 성능 저하

#### 메모리 사용량 확인하기
free 명령어
전체 메모리 용량, 사용 중인 용량, 캐싱 영역의 용량(buffers, cached)

buffers
버퍼 용도로 사용하고 있는 메모리 양. 시스템 성능 향상을 위해서 커널에서 사용하고 있는 영역

cache
페이지 캐시라고 불리는 캐시 영역에 있는 메모리 양을 의미 I/O 관련 작업을 더 빠르게 진행하기 위해 커널에서 사용하고 있는 영역.

used
버퍼와 캐시를 제외하고 사용하고 있는 영역
(shared 메모리도 제외지만, 너무 작음)

free
아직 사용하지 않는 메모리 양

avaliable
버퍼와 캐시를 제외하고 사용하지 않는 영역

#### buffers cached 영역
![image](https://github.com/yujindonut/Study/assets/78431728/b6d8c0dd-8d60-41c1-aa03-0488cb4d8da9)

커널은 블록 디바이스라고 부르는 디스크로부터 데이터를 읽거나 사용자의 데이터를 디스크에 저장
디스크는 다른 장치들에 비해 매우 느리기 때문에 디스크에 대한 요청을 기다리는 시간이 상당히 많이 소요되고, 이로 인해 시스템에 부하가 일어남.
커널은 이렇게 상대적으로 느린 디스크에 대한 요청을 좀 더 빠르게 하기 위해 메모리의 일부를 디스크 요청에 대한 캐싱 영역으로 할당해서 사용함
한번 읽은 디스크의 내용을 메모리에 저장해 두어서, 동일한 내용을 읽고자 하면 디스크로 요청하지 않고 메모리로 요청하게 된다. 이런 캐싱 기능을 통해서 커널은 다수의 디스크 요청을 좀 더 빠르게 처리할 수 있다.
이때 사용되는 캐싱 영역을 buffers, cached라고 부름

#### buffers, cached 차이점

커널이 블록 디바이스에서 데이터를 읽을 때 데이터가 위치한 특정 블록의 주소를 넘겨주고, 블록 디바이스는 해당 블록 주소의 데이터를 커널에 전달한다.

커널이 읽어야 할 데이터가 파일의 내용이라면 커널은 bio 구조체를 만들고 해당 구조체에 Page cache 용도로 할당한 메모리 영역을 연결해준다. 그리고 bio 구조체는 디바이스 드라이버와 통신해서 디스크로부터 데이터를 읽어서 Page Cache에 파일의 내용을 채운다.

super block, inodek block처럼 파일의 내용이 아닌 파일 시스템을 관리하기 위한 메타 데이터를 읽어올 때는 bio 구조체를 사용하지 않고 _get _blk()와 같은 내부 함수를 통해 블록 디바이스와 직접 통신한다. 이때 가져온 블록 디바이스의 특정 블록 내용을 buffer cache 영역에 저장해 둔다.

Page Cache는 파일의 내용을 저장하고 있는 캐시, Buffer Cache는 파일 시스템의 메타 데이터를 담고 있는 블록을 저장하고 있는 캐시라고 할 수 있다.

#### /proc/meminfo 읽기

free 명령은 전체 시스템이 사용하고 있는 메모리와 가용 메모리를 빠르게 읽을 수 있지만 시스템의 메모리 전체 사용량을 알려주지는 않는다.

자세하게 보고 싶다면 /proc/meminfo 파일을 읽으면 된다.
![image](https://github.com/yujindonut/Study/assets/78431728/fc478ece-42b8-436c-9a81-fa0bbb8102b7)

#### Active 영역 VS Inactive 영역
![image](https://github.com/yujindonut/Study/assets/78431728/a139bfa1-ec6a-4fb8-ac2b-75a844528362)
결과적으로 잘 사용하는 영역은 Active 리스트에 남고 자주 사용되지 않는 영역은 Inactive 영역에 남게된다. 그리고 참조 시기가 오래될수록 Inactive 영역으로 이동하고 이후 free 영역으로 이동한다

##### Active에서 Inactive로의 이동은?
메모리 할당이 실패하거나 메모리가 부족하게 되면 kswapd 혹은 커널 내부에서 try_to_free_pages() 함수를 통해서 LRU 리스트에 있는 메모리를 확인. 이 과정에서 Active 리스트에 있던 페이지가 Inactive 리스트로 옮겨가거나 Inactive 리스트에 있던 페이지가 해제되어 다른 프로세스에게 할당되는 작업이 이루어짐

#### slab 메모리 영역
/proc/meminfo 에서 아직 설명하지 않은 영역이 있는데 slab 영역들이다.

이 영역들은 커널이 내부적으로 사용하는 영역을 뜻한다.

주로 I/O 작업을 더 빠르게 하기 위해서 inode cache, dentry cache 등에 사용하거나 네트워크 소켓을 위한 메모리 영역을 확보하는 작업들을 한다.

inode_cache 는 파일의 inode 에 대한 정보를 지정해두는 캐시라면 dentry 는 디렉터리의 계층 관계를 저장해두는 캐시다.

즉 dentry 는 ls 명령으로 디렉터리를 살펴보기만 해도 값이 증가한다. 만약 파일에 자주 접근하고 디렉터리의 생성/삭제가 빈번한 시스템이라면 Slab 메모리가 늘어날 수 있다.

/proc/meminfo 에 있는 영역 중 slab 과 관련된 영역은 다음과 같다.

- Slab: 메모리 영역 중 커널이 직접 사용하고 있는 영역을 말한다.
- SReclaimable: Slab 영역 중 캐시용도로 사용하고 있는 영역이며 메모리 부족 현상이 일어나면 프로세스에게 할당될 수 있는 영역이다.
- SUnreclaim: 커널이 현재 사용중인 영역을 말하며 해제할 수 없는 영역이다.

- Slab 메모리는 buffers/cached 영역에 포함되지 않고 free 명령으로 조회했을 때 used 에 포함된다.

