### 2.1 시스템의 상태 살피기

top 명령은 시스템의 상태를 전반적으로 가장 빠르게 파악할 수 있는 명령 중 하나이다.
옵션 없이 top을 사용하면 기본3초 간격으로 화면을 갱신하면서 정보를 보여준다.
```
# top -b -n 1: 순간의 top정보를 확인하기 위한 옵션
```

- up ~days
  - 서버의 시간과 서버가 얼마나 구동되었는지

- user
  - 몇명의 유저가 로그인해있는지, 시스템의 LoadAverage는 어느정도인지를 보여주는 데이터로
- ~zombie
  - 현재 시스템에서 구동중인 프로세스의 개수를 나타낸다. 출력 결과에는 Tasks로 표현되어 있는 부분이 바로 프로세스의 수와 관련된 정보이다.

![image](https://github.com/yujindonut/Study/assets/78431728/4969489a-4d6f-4695-b7d4-5c2e9c640982)


- CPU, Mem, swap 
  - 메모리의 사용량이다. swap 메모리가 상단에 있다는 것은 swap 메모리 사용여부가 시스템의 상태에 중요한 영향을 끼친다는 뜻으로 해석될 수 있다.

- PR 
  - 프로세스의 실행 우선 순위, 즉 다른 프로세스들보다 더 먼저 실행되어야하는지의 여부를
- NI 
  - PR을 얼마만큼 조절할 것인지를 결정
- VIRT, RES, SHR
  - 프로세스가 사용하는 메모리의 양이 얼마인지를 확인할 수 있는 정보로, 
    이를 통해 프로세스에 메모리 누수가 있는지를 확인할 수 있어 중요한 정보 중 하나이다.

- S
  - S는 프로세스의 상태를 나타내는 정보. 
  현재 CPU를 사용하면서 작업하는 상태인지, I/O를 기다리는 상태인지, 아니면 아무 작업도 하지 않는 유휴 상태인지를 나타낸다.


### 2.2 VIRT, RES, SHR
- VIRT 
  - task가 사용하고 있는 virtual memory의 전체 용량이라고 설명
  - 실제로는 할당되지 않은 가상의 공간이기에 값이 크다하더라도 문제가 되지 않는다.
- RES
  - 현재 task가 사용하고 있는 물리 메모리의 양을 의미
  - 실제 사용하고 있는 메모리는 메모리 점유율이 높은 프로세스를 찾기 위해서는 RES 영역이 높은 프로세스를 찾아야함.
- SHR
  - 다른 프로세스와 공유하고 있는 shared memory의 양을 의미
  - 예 ) 공유 라이브러리 - 다수의 프로세스가 공유 메모리 영역에 올려서 함께 사용할 수 있도록

### 2.3 Virt와 RES 그리고 Memory Commit의 개념

VIRT 와 RES로  구분되어 있는 이유 뭘까?
VRIT로 표현되는 가상 메모리는 프로세스가 커널로부터 사용을 예약받은 메모리이다. 
프로세스는 **malloc()** 과 같은 시스템 콜로 자신이 필요로 하는 
메모리의 영역을 할당해줄 것을 요청한다. 이에 대해 커널은 가용한 공간이 있다면 성공 메시지와 함께 해당 프로세스가 사용할 수 있도록 가상의 메모리 주소를 전달해준다.
이때에도 물리메모리에 해당 영역이 할당된 것이 아니다. 

##### Memory Commit
커널은 프로세스가 메모리를 요청할때 그에 맞는 크기를 할당해주지만 해당 영역을 물ㄹ리 메모리에 바로 할당하지는 않는다. 
메모리 사용과 관련해서 중요한 부분은 VIRT가 아니라 실제로 메모리를 쓰고 있는 RES임을 확인할 수 있다.
vm.overcommit_memory 파라미터를 이용해 커널의 메모리 커밋 동작 방식을 제어할 수 있으며, 프로세스에 할당되는 VIRT 메모리의 양도 제어할 수 있다.

- vm.overcommit_memory = 0
  - overcommit할 수 있는 최대값은 page cache와 swap 영역 그리고 slab reclaimable을 합한 값
- vm.overcommit_memory = 1
  - 무조건적으로 commit 실행
- vm.overcommit_memory = 2
  - 제한적으로 Commit을 진행. 메모리 누수가 있는 프로세스가 있따면 시스템 응답 불가 현상을 일으킬 수 있다.

### 2.4 프로세스의 상태 보기

- Running or Runnable (R)
- Uninterruptible Sleep (D)
- Interruptable Sleep (S)
- Stopped (T)
- Zombie (Z)

S 상태의 프로세스가 많은 것은 시스템에 큰 영향을 끼치지 않는다. 
하지만, D 상태의 프로세스가 많으면 특정 요청이 끝나기를 기다리고 있는 프로세스가 많다는 것을 의미하고,
이 프로세스들은 요청이 끝나면 R상태로 다시 돌아가야하기 때문에 시스템의 부하를 계산하는데 포함된다.

##### 좀비 프로세스가 문제가 될까?
좀비 프로세스는 시스템의 리소스를 차지하지 않기 때문에 그 존재 자체는 큰 문제가 되지 않는다.
스케줄러에 의해 선택되지 않기 때문에 당연히 CPU를 사용하지 않고, 좀비 프로세스 자체는 이미 사용이 중지된 프로세스이기 때문에 메모리를 사용하지 않는다.
좀비 프로세스가 점유하고 있는 PID 때문에, 새로운 프로세스에 할당할 PID가 모자르게 되며, PID를 할당하지 못하는 PID 고갈을 일으키게 된다.

### 2.5 프로세스의 우선순위
- PR과 NI : 커널이 프로세스를 스케줄링할 때 사용하는 우선순위를 나타내는 값

CPU 마다 Run Queue 라는 것이 존재하며, Run Queue 에는 우선순위 별로 프로세스가 연결되어 있다.
Scheduler는 유휴 상태에 있던 프로세스가 깨어나거나 특정 프로세스가 스케줄링을 양보하는 등의 경우에 현재 Run Queue 에 있는 프로세스들 중 가장 우선순위가 높은 프로세스를 꺼내서 Dispatcher 에 넘겨준다.
Dispatcher 는 현재 실행 중인 프로세스의 정보를 다른 곳에 저장한 후 넘겨받은 프로세스의 정보를 가지고 다시 연산을 하도록 요청한다.

RT(RealTime) 스케줄러는 일반적인 사용자가 생성한 프로세스에 적용되는 스케줄러가 아니다. 반드시 특정 시간 안에 종료되어야 하는 중요한 프로세스들, 바로 커널에서 사용하는 데몬들이 대상이다.
RT 스케줄러의 적용을 받게되는 프로세스들은 CFS(Completely Fair Scheduling) 스케줄러보다 더 먼저 실행된다.

이는 안정적인 운영을 위한 것이다. 메모리가 부족한 상태에서 사용하지 않는 메모리들을 회수하고 관리하는 프로세스가 일반적인 사용자 프로세스보다 더 중요하기 때문이다.