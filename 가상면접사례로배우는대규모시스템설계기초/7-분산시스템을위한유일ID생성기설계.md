## 분산시스템을 위한 유일 ID 생성기 설계

auto_increment속성으로 기본키를 사용하면, 분산환경에서는 이 접근법이 통하지 않는다!

여러 데이터 베이스를 사용하는 경우에는 지연시간을 낮추기가 무척 힘들다!

### 문제 이해 및 설계 범위확정

- ID는 유일해야한다
- ID는 숫자로만 구성되어야한다.
- ID는 64비트로 표현될 수 있는 값이여야한다.
- ID는 발급 날짜에 따라 정렬 가능해야한다.
- 초당 10,000개의 ID를 만들 수 있어야한다.

### 개략적 설계안 제시 및 동의구하기

- 다중 마스터 복제
    - auto_increment의 기능을 활용. k만큼의 서버만큼 증가시키는 방법.
    - 단점
        - 여러 데이터 세너에 걸처 규모를 늘리기 어렵다.
        - ID의 유일성은 보장되지만, 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없다.
        - 서버를 추가하거나 삭제할때 동작이 잘 되지 않는다.
- UUID
    - 유일성이 보장되는 ID를 만드는 간단한 방법
    - UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수이다.
    - 장점
        - UUID를 만드는 것 간단. 서버 사이의 조율이 필요 없으므로 동기화 이슈도 없다.
        - 각 서버에 독립적으로 쓸 ID를 만들어, 규모 확장도 쉽다.
    - 단점
        - ID가 128비트로 길다.
        - 시간순으로 정렬이 불가능하다.
        - 숫자 아닌 값이 포함된다.
- 티켓서버
    - 유일성이 보장되는 ID를 만들어내는데 쓰일 수 있는 방법
    - auto_increment 기능을 갖춘 데이터베이스 서버를 중앙 집중형으로 하나만 사용한다.
    - 장점
        - 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
        - 구현하기 쉽고, 중소 규모 애플리케이션에 적합하다..
    - 단점
        - 티켓서버가 SPOF가 된다. 이 서버에 장애가 발생하면, 해당 서버를 이용하는 모든 시스템이 영향을 받는다. 이 이슈를 피하려면 티켓 서버를 여러대 준비해야하고 데이터 동기화 이슈가 생긴다.
- 트위터 스노플레이크 접근법
    - 격파전략
        - 사인비트 : 1비트
        - 타임스탬프: 41비트.
        - 데이터센터 ID : 5비트 할당.
        - 서버 ID : 5비트
        - 일련번호: 12비트. 각 서버에서 ID를 생성할때마다 일련 번호를 1만큼 증가시킨다. 이 값은 1밀리초가 경과할때마다 0으로 초기화된다.


### 상세 설계

데이터센터 ID와 서버 ID는 시스템이 시작할 때 결정되며, 일반적으로 시스템 운영중에는 바뀌지 않는다. 데이터센터 ID나 서버 ID를 잘못 변경하게 되면 ID충돌이 발생할 수 있다.

- 타임스탬프
    - 타임스탬프는 시간이 흐름에 따라 점점 큰 값을 갖게 되므로 ID는 시간순으로 정렬이 가능합니다.
    - 41비트로 표현할 수 있는 타임스탬프의 최대값은 69년. 이 ID생성기는 69년만 정상 작동하므로, 69년이 지나면 기원 시각을 바꾸거나 ID 체계를 다른 것으로 이전하여야한다.
- 일련번호
    - 일련번호는 12비트이므로 어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어낸 경우에만 0보다 큰 값을 갖게된다.

### 마무리

- 시계 동기화 : 이번 설계를 진행하면서 우리는 ID 생성 서버들이 전부 같은 시계를 사용한다고 가정하였다. 이런 가정이 안맞는 경우 NTP(Network Time Protocol)이 해결할 수 있는 보편적 수단이다.
- 각 절의 최적화 : 동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호 절의 길이를 줄이고 타임 스탬프 절의 길이를 늘리는 것이 효과적일 수도 있다.
- 고가용성 : ID 생성기는 필수 불가결 컴포넌트이므로 아주 높은 가용성을 제공해야할 것이다.